\documentclass[12pt,
openright, 
oneside,
%twoside, %TCC: Se seu texto tem mais de 100 páginas, descomente esta linha e comente a anterior
a4paper,
brazil]{facom-ufu-abntex2}

%\usepackage[disable]{todonotes}
\usepackage[colorinlistoftodos]{todonotes}	%use a linha anterior para esconder os todos.
\usepackage{amsthm}
\usepackage{listings}
\usepackage{forest}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[portuguese, ruled, linesnumbered]{algorithm2e}


\newcommand{\codigo}{
\lstset{
	language=C++,
    basicstyle=\ttfamily\tiny,
    stringstyle=\color{red},
    commentstyle=\color{green},
    morecomment=[s][\color{blue}]{/**}{*/},
    extendedchars=true,
    showspaces=false,
    showstringspaces=false,
    numbers=left,
    numberstyle=\tiny,
    breaklines=true,
    breakautoindent=true,
    breakatwhitespace=true,
}}

\renewcommand{\lstlistingname}{Listagem}

\theoremstyle{definition}
\newtheorem*{definition}{Definição}

\autor{José Augusto Bolina Lucas} %TCC
\data{2018}
\orientador{Lásaro Jonas Camargos} %TCC

\titulo{Revisitando o P4 Paxos} %TCC

\renewcommand{\thesection}{\arabic{chapter}.\arabic{section}}

\begin{document}

% ----------------------------------------------------------
% ELEMENTOS PRÉ-TEXTUAIS
% ----------------------------------------------------------
%\pretextual
\imprimircapa
\imprimirfolhaderosto

%\begin{resumo} %TCC:

% \vspace{\onelineskip}

% \noindent
% \textbf{Palavras-chave}: Acordo de Nível de Serviço (SLA), Monitoramento, Multicaminhos,
% OpenFlow, Qualidade de Serviço (QoS), Redes Definidas por Software. %TCC:

%\end{resumo}

%% ---
%% inserir lista de símbolos, se for adequado ao trabalho. %TCC:
%% ---


%\begin{siglas}
%\end{siglas}

%\begin{simbolos}
%  \item[$ \Gamma $] Letra grega Gama
%  \item[$ \Lambda $] Lambda
%  \item[$ \zeta $] Letra grega minúscula zeta
%  \item[$ \in $] Pertence
%\end{simbolos}
%% ---

% ---
% inserir o sumario
% ---
\pdfbookmark[0]{\contentsname}{toc}
\tableofcontents*
\cleardoublepage
% ---


% ----------------------------------------------------------
% ELEMENTOS TEXTUAIS
% ----------------------------------------------------------
\textual

% \todo{A estrutura do texto está excelente. A explicação do paxos está bem legal, mais detalhada do que esperava. É preciso falar mais na intro sobre o trabalho que estamos replicando (duas ou três linhas). Depois de terminar de preencher, precisaremos dar uma revisada no texto pois tem muitas redundâncias. Depois que tiver ficado um tempo sem ler, você mesmo as perceberá.}

% ######################### INICIO ###########################################
\chapter{Introdução}

Com o avanço da tecnologia a interação com a computação se tornou diária, mesmo
nos mínimos detalhes sempre se interage com algum software no dia a dia. Com
esse grande aumento na utilização de softwares e do aprimoramento de novas tecnologias, 
surge a necessidade de aplicações resilientes e tolerantes a falhas. 

Uma aplicação tolerante a falhas consegue manter o funcionamento mesmo com a eventual 
falha de um de seus componentes. Como é possível existir eventos inesperados que podem
causar a eventual falha - ou \textit{crash} - de um servidor, são necessários métodos
para garantir a consistência quando a aplicação retornar com seu funcionamento
normal. 

Uma maneira de possuir uma aplicação tolerante a falhas é a replicação de máquinas
de estado, onde o serviço é modelado como uma máquina de estados determinísticos, e o
serviço é executado em cada réplica \citep{santos2012state}, dessa maneira é mantida
a consistência da aplicação, mas um \textit{overhead} é adicionado na execução
de comandos, pois as réplicas precisam ser consistentes entre si. No centro da replicação
de máquina de estados, existe um problema de consenso, onde o conjunto de réplicas deve 
chegar a um consenso e decidir sobre qual é o estado válido e decidir sobre qual 
transição será realizada. 

Para alcançar o consenso e obter uma aplicação tolerante a falhas, o algoritmo
Paxos é extensivamente utilizado com esse intuito \citep{dang2016paxos}. 
O algoritmo realiza uma custosa trocas de mensagens entre seus agentes. Por se 
tratar de um ambiente distribuído as mensagens podem demorar um tempo arbitrário 
para chegar ao destinatário ou se perder durante a transmissão. Para conseguir 
uma melhora na performance na execução do algoritmo, pode-se realizar a 
implementação do Paxos no dispositivos físicos da rede \citep{dang2016paxos}.

Com a utilização da linguagem P4, é aberta a possibilidade de se programar dispositivos
de rede. Com a utilização de uma tabela \textit{match+action} é possível 
realizar um processamento customizado dos pacotes sendo transportados, de forma a
se diminuir a latência do algoritmo e os pacotes atravessariam menos \textit{hops}.

Alguns exemplos de aplicações que realizam replicação de máquinas de estados, são,
por exemplo OpenReplica \citep{openreplica} e Google Chubby \citep{27897}. Aplicações
de replicação são críticas em data centers, que precisam sempre manter o serviço 
disponível, com informações consistentes, logo, a maneira como um algoritmo de consenso
funciona para realizar a replicação de máquina de estados influencia na performance 
de um data center.

Existe um trabalho posterior, publicado em 2016 em que o atual projeto se norteia para
execução \citep{dang2016paxos}. O trabalho possui visões promissoras para o desenvolvimento
e pesquisa nas linguagens de programação de planos de dados e vislumbra o que pode ser
novos desafios nas pesquisas de protocolos de consenso. O presente projeto dá atenção maior
ao primeiro fator citado, realizando a implementação do algoritmo de consenso Paxos utilizando
a linguagem de programação de planos de dados P4.

\section{Justificativas}
Com a utilização do algoritmo Paxos para resolução do problema de consenso e para a 
construção de uma aplicação tolerante a falhas, é necessário uma comunicação entre os 
agentes pertencentes a aplicação. Essa comunicação, pode se tornar dispendiosa, pois 
a troca de mensagens entre as partes podem ter falhas e ser prolongada até que o 
algoritmo alcance seu objetivo que é o consenso.

Desta forma, essa comunicação poderiam influenciar na performance da aplicação e em 
sua disponibilidade, visto que esse processamento é realizado pela própria aplicação ou 
em servidores que tem essa função delegada.

Visando esse problema, o presente projeto busca obter uma melhora na performance de 
execução do Paxos e obter uma resposta do algoritmo de forma mais rápida e menos 
custosa, realizando a implementação do algoritmo em dispositivos de rede.

\section{Objetivos}
Com a possibilidade de programação em dispositivos de redes, o presente trabalho 
visa realizar a implementação do algoritmo Paxos nos dispositivos
de rede, especificamente \textit{switches}, utilizando a linguagem $P4_{16}$. 
Desta maneira, conseguindo uma melhora na performance do algoritmo, pois uma parte 
que seria executado em um servidor se moveria para ser executado nesses dispositivos, assim
as mensagens seriam processadas enquanto estão sendo roteadas e atravessando menos
\textit{hops}, resultando na redução da latência.

Inicialmente, alcançando os resultados obtidos em um projeto passado \citep{dang2016paxos},
como citado pelos pesquisadores do projeto passado, o algoritmo Paxos é uma implementação
não trivial para linguagem P4, e, como um dos principais pontos deixado pelos pesquisadores
seria em relação ao desenvolvimento e evolução das linguagens de programação de plano de dados,
um dos objetivos seria também uma nova perspectiva acerca das linguagens de programação de 
planos de dados, especificamente a linguagem P4, que sofreu um amadurecimento com o tempo 
percorrido desde o projeto passado.

\section{Método}
O método utilizado para o desenvolvimento do projeto foi divido em três partes, para
ser realizado uma análise em cada uma das partes do projeto separadamente, assim deixando uma
visão mais clara acerca do decorrer do projeto.

\subsection{Fase 1}
Replicação do antigo projeto feito utilizando a linguagem $P4_{14}$, realização de simulações
para verificar o funcionamento do projeto. As simulações serão realizadas utilizando o
Mininet para construir a rede e comunicação.

\subsection{Fase 2}
Transposição do projeto da linguagem $P4_{14}$ para a linguagem $P4_{16}$, onde serão relatadas
o que foi possível ou não de ser realizado com as funcionalidades ofertadas pela linguagem na
sua versão mais atual e um comparativo entre as duas linguagens.

\subsection{Fase 3}
A terceira e última fase será composta pela análise e implementação de melhorias na versão
utilizando a linguagem $P4_{16}$, serão realizadas simulações também utilizando o Mininet
para verificação do comportamento na rede e uma comparação entre a nova e atual versão do
projeto e possíveis pontos para futuras aplicações e pesquisas.

\section{Cronograma}
O projeto será realizado em dois semestres, cada semestre compreende 18 semanas, sendo assim,
um tempo total de desenvolvimento de 36 semanas ou aproximadamente 8 meses. A tabela 
\ref{tab:atividades} demonstra como serão realizadas as atividades no decorrer dos meses. \todo{preferiria um cronograma semana a semana, dado que o prazo de execução é tão curto}

\begin{table}[h!]
    \begin{tabular}{|p{8cm}|c|c|c|c|c|c|c|c|}
    \hline
    Atividades & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
    \hline
    \hline
     
    Revisão trabalhos correlatos & X & X & & & & & &  \\
    \hline 
    
    Revisão Paxos & & X & X & & & & & \\
    \hline
    
    Revisão P4 & & & X & X & & & & \\
    \hline
    
    Primeira fase do método & & & & X & & & & \\
    \hline
    
    Segunda fase do método & & & & & X & & & \\
    \hline
    
    Terceira fase do método & & & & & & X & & \\
    \hline
    
    Correção da monografia & & & & & & & X & \\
    \hline
    
    Monografia & & X & X & X & X & X & & \\
    \hline
    
    Defesa do trabalho de conclusão de curso & & & & & & & & X \\
    \hline
\end{tabular}
    \caption{Tabela de atividades}
    \label{tab:atividades}
\end{table}

%######################### FUNDAMENTACAO ##################################
\chapter{Fundamentação Teórica}
Esse capítulo manterá o foco em detalhar e explicar as técnicas utilizadas
para realização do projeto. Não serão abordadas questões de implementação,
serão explicadas somente de modo teórico, a fim de auxiliar o entendimento do leitor.

\section{Referencial Teórico}
Para seguirmos uma linha de raciocínio linear, e melhorar entendimento da teoria
para compreender o projeto, será abordado inicialmente informações sobre o 
algoritmo Paxos, seu modo de operar e flexibilidade para resolução de problemas.

Em seguida será abordado como se dá o funcionamento de linguagens de programação 
para o plano de dados e será explicado como é o funcionamento da linguagem P4, 
especificamente a versão utilizada para o desenvolvimento deste projeto.

E para finalizar o referencial teórico, será explicado sobre o Mininet, de que
maneira funciona e qual o intuito na sua utilização no projeto.

\subsection{Paxos}
Para iniciar a explicação sobre Paxos, será explicado de onde surgiu o algoritmo e qual
problema ele busca resolver para uma melhor contextualização. Paxos foi criado por 
Leslie Lamport e foi publicado inicialmente em 1989, e consiste em uma família de algoritmos
voltada para resolução de problemas de consenso. 

A ideia de consenso é a de compartilhar informações entre um grupo de elementos
processadores, de preferência com uma maneira tolerante a falhas \citep{barborak1993consensus}.
Normalmente esse compartilhamento de informações é realizado com o intuito de tomar
uma decisão, por exemplo, os elementos devem decidir se \textit{commitam} ou não
uma transação realizada no banco de dados. 

De maneira básica, os elementos devem propor valores para serem escolhidos, 
comunicar entre si para tomar uma decisão e o valor final é escolhido pela maioria de 
elementos do conjunto.
A escolha da maioria não é necessariamente $\frac{n}{2}+1$, --- sendo $n$ o número
total de elementos processadores --- a decisão do que será maioria para tomada de decisão
pode ser criada pelo projetista, mas sempre visando atender o projeto, levando
em consideração que dentre esses $n$ elementos existirão alguns que falharão, essa maioria
é o quorum.

Para garantir a escolha de um valor e a propagação do valor decidido, o problema
possui alguns requisitos que devem ser atendidos pelos algoritmos. Os requisitos de
segurança são:

\begin{itemize}
    \item Um valor proposto talvez seja aceito
    \item Os elementos não aprendem qual o valor decidido até que um valor 
    tenha sido realmente decidido
    \item Um único valor é decidido
\end{itemize}

Algoritmos para consenso funcionam em estágios que refletem o próprio problema, e para
serem algoritmos tolerante a falhas, devem estar preparados para repetir esses ciclos,
considerando os valores escolhidos no ciclo passado, cada um desses ciclos é conhecido como
\textit{round} \citep{camargos2008multicoordinated}.

Os elementos participantes do Paxos, chamados de agentes, comunicam entre si, e assumem 
um ou mais papéis para a evolução do algoritmo. Os papéis a serem desempenhados são, 
utilizando a nomenclatura fornecida por Lamport \citep{lamport2001paxos}, 
\textit{proposers}, são agentes que propõem algum valor, \textit{acceptors} 
agentes que escolhem um único valor e \textit{learners} que são os agentes que aprendem
qual foi o valor escolhido pelo algoritmo.
Existem alguns papéis de coordenadores, que podem ou não ser utilizados no algoritmo, 
sendo, por exemplo \textit{distinguished proposer}, que iremos explicar ao fim.

A comunicação dos agentes se dá por troca de mensagens, utilizando um modelo assíncrono e
não-bizantino, onde os agentes operam em diferentes velocidades, podem falhar e podem ser
resetados, os agentes possuem um espaço de memória não volátil para armazenar informações.
As mensagens podem levar um tempo arbitrário para serem entregues, podem ser perdidas, podem
ser duplicadas, mas nunca são corrompidas \citep{lamport2001paxos}.

\subsubsection{Escolha do valor}
A explicação para o entendimento do Paxos será iniciada pela escolha de um valor. 
Quando uma mensagem, com algum
valor proposto chega para o \textit{acceptor}, esse valor pode ou não ser aceito, logo,
um \textit{acceptor} deve ser capaz de aceitar um valor proposto, desta maneira temos a seguinte 
definição:

\begin{definition}
$P_1$: um \textit{acceptor} deve aceitar o primeiro valor que receber.
\end{definition}

Mas para se chegar a um consenso e um único valor ser decidido pelos agentes, cada um
dos agentes deve ter escolhido o mesmo valor. Desta forma, os \textit{acceptors} devem
ser capazes de aceitar mais de uma proposta e também devem conseguir identificar qual
a proposta aceita, onde cada \textit{acceptor} possui um histórico de quais foram as
propostas aceitas.

As propostas enviadas devem possuir um identificador, possível de ser ordenado e que não 
possa ser repetido por outra proposta, para não existir diferentes propostas com o mesmo
identificador no algoritmo, adiante as propostas serão simbolizadas por 
\textit{(n, v)}, sendo a proposta com identificador $n$ e valor $v$.

Mas para os \textit{acceptors} escolherem mais de uma proposta, deve-se existir a garantia de
que todas as propostas enviadas possuam o mesmo valor, disso, surge a seguinte definição:

\begin{definition}
$P_2$: se uma proposta $(n, v)$ foi decidida, então todas propostas escolhidas com 
identificador $>n$ devem possuir valor $v$.
\end{definition}

Como os identificadores podem ser ordenados, a propriedade de que somente um valor é escolhido
é mantida pelo algoritmo. Como, para ser decidida, uma proposta tem que ter sido escolhida
por pelo menos um \textit{acceptor}, para fortalecer $P_2$, surge a seguinte definição:

\begin{definition}
$P_2^a$: se uma proposta $(n, v)$ foi decidida, então todas propostas com identificador
$>n$ escolhidas por um \textit{acceptor}, possui valor $v$.
\end{definition}

Mas a definição $P_2$ ainda precisa ser reforçada, pois ainda existem cenários onde a 
definição pode ser violada, um desses cenários exemplificado por Lamport, é o seguinte. 
Sempre se mantem $P_1$ para uma proposta ser escolhida, mas como
a comunicação é assíncrona, uma proposta pode ser escolhida por um \textit{acceptor c} 
que nunca tenha escolhido nenhuma proposta antes, e como os agentes podem falhar, suponha
que um \textit{proposer} envie uma proposta com identificador maior e com um valor qualquer.
O \textit{acceptor c} escolheria essa proposta, isso violaria a definição $P_2^a$. Para
fortalecer a definição, se tem o seguinte:

\begin{definition}
$P_2^b$: se uma proposta $(n, v)$ foi decidida, então todas propostas com identificador
$>n$ enviadas por um \textit{proposer}, possui valor $v$.
\end{definition}

Finalmente, para assegurar $P_2$, se tem a seguinte definição:

\begin{definition}
$P_2^c$: Para qualquer proposta $(n, v)$ enviada, existe um conjunto $S$ de
\textit{acceptors}, que cairá em um dos casos:

\begin{enumerate}
    \item $S$ não possui nenhum \textit{acceptor} que tenha escolhido uma proposta com 
identificador $<n$.

    \item $v$ é o valor da proposta com o maior identificador dentre as propostas com o 
menor identificador $<n$ escolhidas pelo conjunto $S$.
\end{enumerate}
\end{definition}

Com essas definições, o algoritmo para envio de propostas funcionará da seguinte maneira,
um \textit{proposer} envia proposta com identificador $n$ para conjunto de 
\textit{acceptors}, esperando uma das seguintes respostas:

\begin{itemize}
    \item Promessa de não aceitar valor $<n$
    \item Se existir, proposta com maior identificador $<n$
\end{itemize}

Se receber uma resposta da maioria dos \textit{acceptors}, enviar a proposta
$(n, v)$, sendo $v$ o valor da proposta de maior identificador recebido nas respostas,
senão, um valor escolhido pelo próprio \textit{proposer}.

Esses passos do algoritmo receberam um nomenclatura, que são \textit{prepare} e
\textit{accept}, respectivamente. O algoritmo em pseudo-código fica de seguinte maneira:

\begin{algorithm}[H]
\caption{Envio de propostas}
\SetAlgoLined
\Inicio{
$A$ = conjunto de \textit{acceptors}

$n$ = identificador

$respostas$ = []

\Para{cada $a \in A$}{
    $resposta$ = prepare($n$)
    
    adicione $resposta$ em $respostas$
}

\Se {aceito pela maioria}{
        $v$ = $v$ da proposta com maior identificador $\in respostas$ ou algum valor proposto
        
        \Para{cada $a \in A$}{
            accept($(n, v)$)
        }
    }
}
\end{algorithm}

Com esse algoritmo para envio de propostas, tem-se que um \textit{acceptor} irá
receber requisições do tipo \textit{prepare} e \textit{accept}, para evitar um \textit{overhead}
de requisições e mensagens, o \textit{acceptor} pode ignorar requisições de qualquer tipo,
mas pode responder requisições do tipo \textit{prepare}, se, e somente se, não estiver
prometido a outra proposta. Assim, para finalizar, tem-se:

\begin{definition}
$P_1^a$: um \textit{acceptor} pode aceitar qualquer proposta $(n, v)$, sse não tiver
respondido um requisição \textit{prepare} com identificador $>n$.
\end{definition}

Desta forma, o algoritmo para envio de proposta está totalmente definido. Para se definir
o algoritmo para escolha de valores, deve-se assegurar que um \textit{acceptor} se
lembre da proposta com maior identificador que já escolheu e lembrar o maior identificador
que da requisição de \textit{prepare} que respondeu, essas informações devem ser mantidas
em uma memória não volátil, para que não sejam perdidas em eventuais falhas.

O algoritmo final para escolha é definido a seguir, separado em duas fases:

\begin{itemize}
    \item [Fase 1]
    \begin{itemize}
        \item [a] Um \textit{proposer} envia um requisição de \textit{prepare} com
        identificador $n$.
        
        \item [b] Se um \textit{acceptor} recebe um \textit{prepare} com identificador
        $n$ sendo o maior identificador que já recebeu, responde com a promessa de não
        aceitar nenhuma proposta com identificador $<n$, juntamente com a proposta com
        maior identificador $<n$, se existir.
    \end{itemize}
    
    \item [Fase 2]
    \begin{itemize}
        \item [a] Se o \textit{proposer} recebe resposta de uma maioria de \textit{acceptors}
        para seu \textit{prepare} de identificador $n$, então, envia um \textit{accept} 
        com identificador $n$ e valor $v$, sendo $v$ o valor da resposta de \textit{prepare}
        com maior identificador, senão, $v$ é um valor escolhido pelo \textit{proposer}.
        
        \item [b] Se um \textit{acceptor} recebe um \textit{accept} com identificador $n$
        ele o aceita, caso no tempo transcorrido tenha respondido um \textit{prepare}
        com identificador $>n$ poderá negar o \textit{accept} recebido.
    \end{itemize}
\end{itemize}

Após o valor ser decidido pelo algoritmo, o valor deve ser propagado para os \textit{learners},
que só conhecem o valor após ser definitivamente decidido.

\subsubsection{Propagação do valor decidido}
Após um valor ser decidido, os \textit{learners} devem conhecer o valor, isso pode ser realizado
de diferentes maneiras, e fica a critério do arquiteto para escolher qual atende melhor o
problema a ser resolvido.

Uma das maneiras de se realizar, seria que cada um dos \textit{acceptors} respondessem para
todos os \textit{learners} qual o valor decidido, assim, resultaria em uma troca de mensagens
$n \cdot m$, o produto entre o número de \textit{acceptors} e o número de \textit{learners}.

Outra maneira de ser realizada essa propagação, aqui entra também o papel de coordenador
citado anteriormente. Os \textit{acceptors} enviam o valor decidido para um
\textit{distinguished learner}, que após conhecer o valor decidido, envia para os
\textit{learners} o valor decidido, esse método teria $n + m$ troca de mensagens,
a soma entre o número de \textit{acceptors} e o número de \textit{learners}. Mas, como os
agentes são suscetíveis a falhas, o \textit{distinguished learner} também pode falhar,
assim impossibilitando a transmissão do valor decidido para os \textit{learners}.

\subsection{P4}
P4 é uma linguagem utilizada para programação do plano de dados em  dispositivos de 
rede \citep{paxos16spec}. Dispositivos de rede possuem dois planos, sendo eles o 
plano de controle e o plano de encaminhamento, também chamado de plano de dados ou 
plano do usuário. 

Pode ser feita uma analogia para se entender a diferença entre o 
plano de controle e o plano de dados, foi eleito de forma honesta, um novo 
funcionário para cuidar do transporte público 
da cidade Zanzizânia. Antes de se enviar os veículos é necessário realizar o 
planejamento de quais o caminhos serão utilizados, as pessoas ainda não foram 
movidas pelos veículos, mas os caminhos e as paradas são conhecidos, essa parte é 
semelhante ao plano de controle, onde são encontradas as rotas.\citep{dataVsControl}.

Numa rede de roteadores, esse planejamento, que é descobrir e aprender novas rotas 
pode ser realizado por rotas estáticas, onde o roteador é ensinado sobre redes remotas
e como acessar essas redes. Pode também ser utilizado protocolos de roteamento dinâmicos,
onde os roteadores aprendem entre si sobre a existência de redes remotas.\citep{dataVsControl}.

Com o plano de rotas definidos para a cidade, agora é possível transportar os cidadãos
para os locais desejados através das ruas. Isso se trata do plano de dados, onde 
um pacote chega e é transportado para outro local, ou interface, através das rotas 
conhecidas \citep{dataVsControl}.

\subsection{Mininet}


\section{Trabalhos Correlatos}
Essa seção visa listar trabalhos relacionados com o presente projeto, alguns destes usados
como material de referência para o desenvolvimento.

Existe um trabalho na área, publicado em 2016 \citep{dang2016paxos}. Neste trabalho,
os pesquisadores utilizaram $P4_{14}$ na versão 1.0.2, e deixaram pontos que podem ser
melhorados no trabalho com a evolução da linguagem, que atualmente se encontra na versão
$P4_{16}$ 1.0.0, que é uma revisão da P4 de 2016 \citep{paxos16spec}.


%######################### DESENVOLVIMENTO ##################################
\chapter{Desenvolvimento}
 
\subsection{Arquitetura do projeto}
\subsection{Arquitetura da rede}
\subsubsection{Cabeçalhos}
\subsubsection{Experimento}
\subsubsection{Código}
\subsubsection{Testes}

%######################### CONCLUSAO ##################################
\section{Conclusão}



\bibliography{references.bib}
\bibliographystyle{plain}

\end{document}

